#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals, unused)]
/* automatically generated by rust-bindgen */

pub const _GLIBCXX_CSTDINT: u32 = 1;
pub const _GLIBCXX_CXX_CONFIG_H: u32 = 1;
pub const _GLIBCXX_RELEASE: u32 = 9;
pub const __GLIBCXX__: u32 = 20200808;
pub const _GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY: u32 = 1;
pub const _GLIBCXX_USE_DEPRECATED: u32 = 1;
pub const _GLIBCXX_EXTERN_TEMPLATE: u32 = 1;
pub const _GLIBCXX_USE_DUAL_ABI: u32 = 1;
pub const _GLIBCXX_USE_CXX11_ABI: u32 = 1;
pub const _GLIBCXX_INLINE_VERSION: u32 = 0;
pub const _GLIBCXX_USE_ALLOCATOR_NEW: u32 = 1;
pub const _GLIBCXX_OS_DEFINES: u32 = 1;
pub const __NO_CTYPE: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _ISOC95_SOURCE: u32 = 1;
pub const _ISOC99_SOURCE: u32 = 1;
pub const _ISOC11_SOURCE: u32 = 1;
pub const _ISOC2X_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _XOPEN_SOURCE: u32 = 700;
pub const _XOPEN_SOURCE_EXTENDED: u32 = 1;
pub const _LARGEFILE64_SOURCE: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_ISOCXX11: u32 = 1;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const __USE_XOPEN: u32 = 1;
pub const __USE_XOPEN_EXTENDED: u32 = 1;
pub const __USE_UNIX98: u32 = 1;
pub const _LARGEFILE_SOURCE: u32 = 1;
pub const __USE_XOPEN2K8XSI: u32 = 1;
pub const __USE_XOPEN2KXSI: u32 = 1;
pub const __USE_LARGEFILE: u32 = 1;
pub const __USE_LARGEFILE64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_GNU: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 0;
pub const _GLIBCXX_CPU_DEFINES: u32 = 1;
pub const _GLIBCXX_FAST_MATH: u32 = 0;
pub const _GLIBCXX_USE_FLOAT128: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_HAS_UNIQ_OBJ_REP: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_IS_AGGREGATE: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_LAUNDER: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED: u32 = 1;
pub const _GLIBCXX_HAVE_ACOSF: u32 = 1;
pub const _GLIBCXX_HAVE_ACOSL: u32 = 1;
pub const _GLIBCXX_HAVE_ALIGNED_ALLOC: u32 = 1;
pub const _GLIBCXX_HAVE_ARPA_INET_H: u32 = 1;
pub const _GLIBCXX_HAVE_ASINF: u32 = 1;
pub const _GLIBCXX_HAVE_ASINL: u32 = 1;
pub const _GLIBCXX_HAVE_AS_SYMVER_DIRECTIVE: u32 = 1;
pub const _GLIBCXX_HAVE_ATAN2F: u32 = 1;
pub const _GLIBCXX_HAVE_ATAN2L: u32 = 1;
pub const _GLIBCXX_HAVE_ATANF: u32 = 1;
pub const _GLIBCXX_HAVE_ATANL: u32 = 1;
pub const _GLIBCXX_HAVE_ATOMIC_LOCK_POLICY: u32 = 1;
pub const _GLIBCXX_HAVE_AT_QUICK_EXIT: u32 = 1;
pub const _GLIBCXX_HAVE_CEILF: u32 = 1;
pub const _GLIBCXX_HAVE_CEILL: u32 = 1;
pub const _GLIBCXX_HAVE_COMPLEX_H: u32 = 1;
pub const _GLIBCXX_HAVE_COSF: u32 = 1;
pub const _GLIBCXX_HAVE_COSHF: u32 = 1;
pub const _GLIBCXX_HAVE_COSHL: u32 = 1;
pub const _GLIBCXX_HAVE_COSL: u32 = 1;
pub const _GLIBCXX_HAVE_DIRENT_H: u32 = 1;
pub const _GLIBCXX_HAVE_DLFCN_H: u32 = 1;
pub const _GLIBCXX_HAVE_EBADMSG: u32 = 1;
pub const _GLIBCXX_HAVE_ECANCELED: u32 = 1;
pub const _GLIBCXX_HAVE_ECHILD: u32 = 1;
pub const _GLIBCXX_HAVE_EIDRM: u32 = 1;
pub const _GLIBCXX_HAVE_ENDIAN_H: u32 = 1;
pub const _GLIBCXX_HAVE_ENODATA: u32 = 1;
pub const _GLIBCXX_HAVE_ENOLINK: u32 = 1;
pub const _GLIBCXX_HAVE_ENOSPC: u32 = 1;
pub const _GLIBCXX_HAVE_ENOSR: u32 = 1;
pub const _GLIBCXX_HAVE_ENOSTR: u32 = 1;
pub const _GLIBCXX_HAVE_ENOTRECOVERABLE: u32 = 1;
pub const _GLIBCXX_HAVE_ENOTSUP: u32 = 1;
pub const _GLIBCXX_HAVE_EOVERFLOW: u32 = 1;
pub const _GLIBCXX_HAVE_EOWNERDEAD: u32 = 1;
pub const _GLIBCXX_HAVE_EPERM: u32 = 1;
pub const _GLIBCXX_HAVE_EPROTO: u32 = 1;
pub const _GLIBCXX_HAVE_ETIME: u32 = 1;
pub const _GLIBCXX_HAVE_ETIMEDOUT: u32 = 1;
pub const _GLIBCXX_HAVE_ETXTBSY: u32 = 1;
pub const _GLIBCXX_HAVE_EWOULDBLOCK: u32 = 1;
pub const _GLIBCXX_HAVE_EXCEPTION_PTR_SINCE_GCC46: u32 = 1;
pub const _GLIBCXX_HAVE_EXECINFO_H: u32 = 1;
pub const _GLIBCXX_HAVE_EXPF: u32 = 1;
pub const _GLIBCXX_HAVE_EXPL: u32 = 1;
pub const _GLIBCXX_HAVE_FABSF: u32 = 1;
pub const _GLIBCXX_HAVE_FABSL: u32 = 1;
pub const _GLIBCXX_HAVE_FCNTL_H: u32 = 1;
pub const _GLIBCXX_HAVE_FENV_H: u32 = 1;
pub const _GLIBCXX_HAVE_FINITE: u32 = 1;
pub const _GLIBCXX_HAVE_FINITEF: u32 = 1;
pub const _GLIBCXX_HAVE_FINITEL: u32 = 1;
pub const _GLIBCXX_HAVE_FLOAT_H: u32 = 1;
pub const _GLIBCXX_HAVE_FLOORF: u32 = 1;
pub const _GLIBCXX_HAVE_FLOORL: u32 = 1;
pub const _GLIBCXX_HAVE_FMODF: u32 = 1;
pub const _GLIBCXX_HAVE_FMODL: u32 = 1;
pub const _GLIBCXX_HAVE_FREXPF: u32 = 1;
pub const _GLIBCXX_HAVE_FREXPL: u32 = 1;
pub const _GLIBCXX_HAVE_GETIPINFO: u32 = 1;
pub const _GLIBCXX_HAVE_GETS: u32 = 1;
pub const _GLIBCXX_HAVE_HYPOT: u32 = 1;
pub const _GLIBCXX_HAVE_HYPOTF: u32 = 1;
pub const _GLIBCXX_HAVE_HYPOTL: u32 = 1;
pub const _GLIBCXX_HAVE_ICONV: u32 = 1;
pub const _GLIBCXX_HAVE_INT64_T: u32 = 1;
pub const _GLIBCXX_HAVE_INT64_T_LONG: u32 = 1;
pub const _GLIBCXX_HAVE_INTTYPES_H: u32 = 1;
pub const _GLIBCXX_HAVE_ISINFF: u32 = 1;
pub const _GLIBCXX_HAVE_ISINFL: u32 = 1;
pub const _GLIBCXX_HAVE_ISNANF: u32 = 1;
pub const _GLIBCXX_HAVE_ISNANL: u32 = 1;
pub const _GLIBCXX_HAVE_ISWBLANK: u32 = 1;
pub const _GLIBCXX_HAVE_LC_MESSAGES: u32 = 1;
pub const _GLIBCXX_HAVE_LDEXPF: u32 = 1;
pub const _GLIBCXX_HAVE_LDEXPL: u32 = 1;
pub const _GLIBCXX_HAVE_LIBINTL_H: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_AS: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_DATA: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_FSIZE: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_RSS: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_VMEM: u32 = 0;
pub const _GLIBCXX_HAVE_LINK: u32 = 1;
pub const _GLIBCXX_HAVE_LINUX_FUTEX: u32 = 1;
pub const _GLIBCXX_HAVE_LINUX_RANDOM_H: u32 = 1;
pub const _GLIBCXX_HAVE_LINUX_TYPES_H: u32 = 1;
pub const _GLIBCXX_HAVE_LOCALE_H: u32 = 1;
pub const _GLIBCXX_HAVE_LOG10F: u32 = 1;
pub const _GLIBCXX_HAVE_LOG10L: u32 = 1;
pub const _GLIBCXX_HAVE_LOGF: u32 = 1;
pub const _GLIBCXX_HAVE_LOGL: u32 = 1;
pub const _GLIBCXX_HAVE_MBSTATE_T: u32 = 1;
pub const _GLIBCXX_HAVE_MEMALIGN: u32 = 1;
pub const _GLIBCXX_HAVE_MEMORY_H: u32 = 1;
pub const _GLIBCXX_HAVE_MODF: u32 = 1;
pub const _GLIBCXX_HAVE_MODFF: u32 = 1;
pub const _GLIBCXX_HAVE_MODFL: u32 = 1;
pub const _GLIBCXX_HAVE_NETDB_H: u32 = 1;
pub const _GLIBCXX_HAVE_NETINET_IN_H: u32 = 1;
pub const _GLIBCXX_HAVE_NETINET_TCP_H: u32 = 1;
pub const _GLIBCXX_HAVE_POLL: u32 = 1;
pub const _GLIBCXX_HAVE_POLL_H: u32 = 1;
pub const _GLIBCXX_HAVE_POSIX_MEMALIGN: u32 = 1;
pub const _GLIBCXX_HAVE_POWF: u32 = 1;
pub const _GLIBCXX_HAVE_POWL: u32 = 1;
pub const _GLIBCXX_HAVE_QUICK_EXIT: u32 = 1;
pub const _GLIBCXX_HAVE_READLINK: u32 = 1;
pub const _GLIBCXX_HAVE_SETENV: u32 = 1;
pub const _GLIBCXX_HAVE_SINCOS: u32 = 1;
pub const _GLIBCXX_HAVE_SINCOSF: u32 = 1;
pub const _GLIBCXX_HAVE_SINCOSL: u32 = 1;
pub const _GLIBCXX_HAVE_SINF: u32 = 1;
pub const _GLIBCXX_HAVE_SINHF: u32 = 1;
pub const _GLIBCXX_HAVE_SINHL: u32 = 1;
pub const _GLIBCXX_HAVE_SINL: u32 = 1;
pub const _GLIBCXX_HAVE_SOCKATMARK: u32 = 1;
pub const _GLIBCXX_HAVE_SQRTF: u32 = 1;
pub const _GLIBCXX_HAVE_SQRTL: u32 = 1;
pub const _GLIBCXX_HAVE_STDALIGN_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDBOOL_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDINT_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDLIB_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRERROR_L: u32 = 1;
pub const _GLIBCXX_HAVE_STRERROR_R: u32 = 1;
pub const _GLIBCXX_HAVE_STRINGS_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRING_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRTOF: u32 = 1;
pub const _GLIBCXX_HAVE_STRTOLD: u32 = 1;
pub const _GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE: u32 = 1;
pub const _GLIBCXX_HAVE_STRXFRM_L: u32 = 1;
pub const _GLIBCXX_HAVE_SYMLINK: u32 = 1;
pub const _GLIBCXX_HAVE_SYMVER_SYMBOL_RENAMING_RUNTIME_SUPPORT: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_IOCTL_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_IPC_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_PARAM_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_RESOURCE_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SDT_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SEM_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SOCKET_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_STATVFS_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_STAT_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SYSINFO_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_TIME_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_TYPES_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_UIO_H: u32 = 1;
pub const _GLIBCXX_HAVE_S_ISREG: u32 = 1;
pub const _GLIBCXX_HAVE_TANF: u32 = 1;
pub const _GLIBCXX_HAVE_TANHF: u32 = 1;
pub const _GLIBCXX_HAVE_TANHL: u32 = 1;
pub const _GLIBCXX_HAVE_TANL: u32 = 1;
pub const _GLIBCXX_HAVE_TGMATH_H: u32 = 1;
pub const _GLIBCXX_HAVE_TIMESPEC_GET: u32 = 1;
pub const _GLIBCXX_HAVE_TLS: u32 = 1;
pub const _GLIBCXX_HAVE_TRUNCATE: u32 = 1;
pub const _GLIBCXX_HAVE_UCHAR_H: u32 = 1;
pub const _GLIBCXX_HAVE_UNISTD_H: u32 = 1;
pub const _GLIBCXX_HAVE_UTIME_H: u32 = 1;
pub const _GLIBCXX_HAVE_VFWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_VSWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_VWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_WCHAR_H: u32 = 1;
pub const _GLIBCXX_HAVE_WCSTOF: u32 = 1;
pub const _GLIBCXX_HAVE_WCTYPE_H: u32 = 1;
pub const _GLIBCXX_HAVE_WRITEV: u32 = 1;
pub const _GLIBCXX_HAVE___CXA_THREAD_ATEXIT_IMPL: u32 = 1;
pub const LT_OBJDIR: &'static [u8; 7usize] = b".libs/\0";
pub const _GLIBCXX_PACKAGE_BUGREPORT: &'static [u8; 1usize] = b"\0";
pub const _GLIBCXX_PACKAGE_NAME: &'static [u8; 15usize] = b"package-unused\0";
pub const _GLIBCXX_PACKAGE_STRING: &'static [u8; 30usize] = b"package-unused version-unused\0";
pub const _GLIBCXX_PACKAGE_TARNAME: &'static [u8; 10usize] = b"libstdc++\0";
pub const _GLIBCXX_PACKAGE_URL: &'static [u8; 1usize] = b"\0";
pub const _GLIBCXX_PACKAGE__GLIBCXX_VERSION: &'static [u8; 15usize] = b"version-unused\0";
pub const STDC_HEADERS: u32 = 1;
pub const _GLIBCXX_DARWIN_USE_64_BIT_INODE: u32 = 1;
pub const _GLIBCXX11_USE_C99_COMPLEX: u32 = 1;
pub const _GLIBCXX11_USE_C99_MATH: u32 = 1;
pub const _GLIBCXX11_USE_C99_STDIO: u32 = 1;
pub const _GLIBCXX11_USE_C99_STDLIB: u32 = 1;
pub const _GLIBCXX11_USE_C99_WCHAR: u32 = 1;
pub const _GLIBCXX98_USE_C99_COMPLEX: u32 = 1;
pub const _GLIBCXX98_USE_C99_MATH: u32 = 1;
pub const _GLIBCXX98_USE_C99_STDIO: u32 = 1;
pub const _GLIBCXX98_USE_C99_STDLIB: u32 = 1;
pub const _GLIBCXX98_USE_C99_WCHAR: u32 = 1;
pub const _GLIBCXX_ATOMIC_BUILTINS: u32 = 1;
pub const _GLIBCXX_FULLY_DYNAMIC_STRING: u32 = 0;
pub const _GLIBCXX_HAS_GTHREADS: u32 = 1;
pub const _GLIBCXX_HOSTED: u32 = 1;
pub const _GLIBCXX_RES_LIMITS: u32 = 1;
pub const _GLIBCXX_STDIO_EOF: i32 = -1;
pub const _GLIBCXX_STDIO_SEEK_CUR: u32 = 1;
pub const _GLIBCXX_STDIO_SEEK_END: u32 = 2;
pub const _GLIBCXX_SYMVER: u32 = 1;
pub const _GLIBCXX_SYMVER_GNU: u32 = 1;
pub const _GLIBCXX_USE_C11_UCHAR_CXX11: u32 = 1;
pub const _GLIBCXX_USE_C99: u32 = 1;
pub const _GLIBCXX_USE_C99_COMPLEX_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_CTYPE_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_FENV_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_INTTYPES_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_INTTYPES_WCHAR_T_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_MATH_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_STDINT_TR1: u32 = 1;
pub const _GLIBCXX_USE_CLOCK_MONOTONIC: u32 = 1;
pub const _GLIBCXX_USE_CLOCK_REALTIME: u32 = 1;
pub const _GLIBCXX_USE_DECIMAL_FLOAT: u32 = 1;
pub const _GLIBCXX_USE_DEV_RANDOM: u32 = 1;
pub const _GLIBCXX_USE_FCHMOD: u32 = 1;
pub const _GLIBCXX_USE_FCHMODAT: u32 = 1;
pub const _GLIBCXX_USE_GETTIMEOFDAY: u32 = 1;
pub const _GLIBCXX_USE_GET_NPROCS: u32 = 1;
pub const _GLIBCXX_USE_INT128: u32 = 1;
pub const _GLIBCXX_USE_LFS: u32 = 1;
pub const _GLIBCXX_USE_LONG_LONG: u32 = 1;
pub const _GLIBCXX_USE_LSTAT: u32 = 1;
pub const _GLIBCXX_USE_NANOSLEEP: u32 = 1;
pub const _GLIBCXX_USE_NLS: u32 = 1;
pub const _GLIBCXX_USE_PTHREAD_RWLOCK_T: u32 = 1;
pub const _GLIBCXX_USE_RANDOM_TR1: u32 = 1;
pub const _GLIBCXX_USE_REALPATH: u32 = 1;
pub const _GLIBCXX_USE_SCHED_YIELD: u32 = 1;
pub const _GLIBCXX_USE_SC_NPROCESSORS_ONLN: u32 = 1;
pub const _GLIBCXX_USE_SENDFILE: u32 = 1;
pub const _GLIBCXX_USE_ST_MTIM: u32 = 1;
pub const _GLIBCXX_USE_TMPNAM: u32 = 1;
pub const _GLIBCXX_USE_UTIME: u32 = 1;
pub const _GLIBCXX_USE_UTIMENSAT: u32 = 1;
pub const _GLIBCXX_USE_WCHAR_T: u32 = 1;
pub const _GLIBCXX_VERBOSE: u32 = 1;
pub const _GLIBCXX_X86_RDRAND: u32 = 1;
pub const _GTHREAD_USE_MUTEX_TIMEDLOCK: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 1;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const INT8_WIDTH: u32 = 8;
pub const UINT8_WIDTH: u32 = 8;
pub const INT16_WIDTH: u32 = 16;
pub const UINT16_WIDTH: u32 = 16;
pub const INT32_WIDTH: u32 = 32;
pub const UINT32_WIDTH: u32 = 32;
pub const INT64_WIDTH: u32 = 64;
pub const UINT64_WIDTH: u32 = 64;
pub const INT_LEAST8_WIDTH: u32 = 8;
pub const UINT_LEAST8_WIDTH: u32 = 8;
pub const INT_LEAST16_WIDTH: u32 = 16;
pub const UINT_LEAST16_WIDTH: u32 = 16;
pub const INT_LEAST32_WIDTH: u32 = 32;
pub const UINT_LEAST32_WIDTH: u32 = 32;
pub const INT_LEAST64_WIDTH: u32 = 64;
pub const UINT_LEAST64_WIDTH: u32 = 64;
pub const INT_FAST8_WIDTH: u32 = 8;
pub const UINT_FAST8_WIDTH: u32 = 8;
pub const INT_FAST16_WIDTH: u32 = 64;
pub const UINT_FAST16_WIDTH: u32 = 64;
pub const INT_FAST32_WIDTH: u32 = 64;
pub const UINT_FAST32_WIDTH: u32 = 64;
pub const INT_FAST64_WIDTH: u32 = 64;
pub const UINT_FAST64_WIDTH: u32 = 64;
pub const INTPTR_WIDTH: u32 = 64;
pub const UINTPTR_WIDTH: u32 = 64;
pub const INTMAX_WIDTH: u32 = 64;
pub const UINTMAX_WIDTH: u32 = 64;
pub const PTRDIFF_WIDTH: u32 = 64;
pub const SIG_ATOMIC_WIDTH: u32 = 32;
pub const SIZE_WIDTH: u32 = 64;
pub const WCHAR_WIDTH: u32 = 32;
pub const WINT_WIDTH: u32 = 32;
pub const _STDIO_H: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const __cookie_io_functions_t_defined: u32 = 1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_DATA: u32 = 3;
pub const SEEK_HOLE: u32 = 4;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const L_cuserid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const RENAME_NOREPLACE: u32 = 1;
pub const RENAME_EXCHANGE: u32 = 2;
pub const RENAME_WHITEOUT: u32 = 4;
pub const _GLIBCXX_CSTDIO: u32 = 1;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _GLIBCXX_CSTRING: u32 = 1;
pub const C_API_DTYPE_FLOAT32: u32 = 0;
pub const C_API_DTYPE_FLOAT64: u32 = 1;
pub const C_API_DTYPE_INT32: u32 = 2;
pub const C_API_DTYPE_INT64: u32 = 3;
pub const C_API_PREDICT_NORMAL: u32 = 0;
pub const C_API_PREDICT_RAW_SCORE: u32 = 1;
pub const C_API_PREDICT_LEAF_INDEX: u32 = 2;
pub const C_API_PREDICT_CONTRIB: u32 = 3;
pub const C_API_MATRIX_TYPE_CSR: u32 = 0;
pub const C_API_MATRIX_TYPE_CSC: u32 = 1;
pub const C_API_FEATURE_IMPORTANCE_SPLIT: u32 = 0;
pub const C_API_FEATURE_IMPORTANCE_GAIN: u32 = 1;
pub type std_size_t = ::std::os::raw::c_ulong;
pub type std_nullptr_t = *const ::std::os::raw::c_void;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(::std::mem::size_of::<__fsid_t>(), 8usize, concat!("Size of: ", stringify!(__fsid_t)));
    assert_eq!(::std::mem::align_of::<__fsid_t>(), 4usize, concat!("Alignment of ", stringify!(__fsid_t)));
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(__fsid_t), "::", stringify!(__val))
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type size_t = ::std::os::raw::c_ulong;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(__mbstate_t__bindgen_ty_1), "::", stringify!(__wch))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(__mbstate_t__bindgen_ty_1), "::", stringify!(__wchb))
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::std::mem::size_of::<__mbstate_t>(), 8usize, concat!("Size of: ", stringify!(__mbstate_t)));
    assert_eq!(::std::mem::align_of::<__mbstate_t>(), 4usize, concat!("Alignment of ", stringify!(__mbstate_t)));
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(__mbstate_t), "::", stringify!(__count))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(__mbstate_t), "::", stringify!(__value))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(::std::mem::size_of::<_G_fpos_t>(), 16usize, concat!("Size of: ", stringify!(_G_fpos_t)));
    assert_eq!(::std::mem::align_of::<_G_fpos_t>(), 8usize, concat!("Alignment of ", stringify!(_G_fpos_t)));
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_G_fpos_t), "::", stringify!(__pos))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_G_fpos_t), "::", stringify!(__state))
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(::std::mem::size_of::<_G_fpos64_t>(), 16usize, concat!("Size of: ", stringify!(_G_fpos64_t)));
    assert_eq!(::std::mem::align_of::<_G_fpos64_t>(), 8usize, concat!("Alignment of ", stringify!(_G_fpos64_t)));
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_G_fpos64_t), "::", stringify!(__pos))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_G_fpos64_t), "::", stringify!(__state))
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: size_t,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(::std::mem::size_of::<_IO_FILE>(), 216usize, concat!("Size of: ", stringify!(_IO_FILE)));
    assert_eq!(::std::mem::align_of::<_IO_FILE>(), 8usize, concat!("Alignment of ", stringify!(_IO_FILE)));
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_flags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_IO_read_ptr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_IO_read_end))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_IO_read_base))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_IO_write_base))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_IO_write_ptr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_IO_write_end))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_IO_buf_base))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_IO_buf_end))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_IO_save_base))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_IO_backup_base))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_IO_save_end))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_markers))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_chain))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_fileno))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_flags2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_old_offset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_cur_column))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_vtable_offset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_shortbuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_lock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_offset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
        152usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_codecvt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
        160usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_wide_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
        168usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_freeres_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
        176usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_freeres_buf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(__pad5))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_mode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!("Offset of field: ", stringify!(_IO_FILE), "::", stringify!(_unused2))
    );
}
pub type cookie_read_function_t =
    ::std::option::Option<unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void, __buf: *mut ::std::os::raw::c_char, __nbytes: size_t) -> __ssize_t>;
pub type cookie_write_function_t =
    ::std::option::Option<unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void, __buf: *const ::std::os::raw::c_char, __nbytes: size_t) -> __ssize_t>;
pub type cookie_seek_function_t =
    ::std::option::Option<unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void, __pos: *mut __off64_t, __w: ::std::os::raw::c_int) -> ::std::os::raw::c_int>;
pub type cookie_close_function_t = ::std::option::Option<unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
#[test]
fn bindgen_test_layout__IO_cookie_io_functions_t() {
    assert_eq!(
        ::std::mem::size_of::<_IO_cookie_io_functions_t>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_cookie_io_functions_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_cookie_io_functions_t>())).read as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_IO_cookie_io_functions_t), "::", stringify!(read))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_cookie_io_functions_t>())).write as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_IO_cookie_io_functions_t), "::", stringify!(write))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_cookie_io_functions_t>())).seek as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(_IO_cookie_io_functions_t), "::", stringify!(seek))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_cookie_io_functions_t>())).close as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(_IO_cookie_io_functions_t), "::", stringify!(close))
    );
}
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
pub type off_t = __off_t;
pub type off64_t = __off64_t;
pub type ssize_t = __ssize_t;
pub type fpos_t = __fpos_t;
pub type fpos64_t = __fpos64_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(__old: *const ::std::os::raw::c_char, __new: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat2(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpfile64() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(__dir: *const ::std::os::raw::c_char, __pfx: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcloseall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(__filename: *const ::std::os::raw::c_char, __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn freopen(__filename: *const ::std::os::raw::c_char, __modes: *const ::std::os::raw::c_char, __stream: *mut FILE) -> *mut FILE;
}
extern "C" {
    pub fn fopen64(__filename: *const ::std::os::raw::c_char, __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn freopen64(__filename: *const ::std::os::raw::c_char, __modes: *const ::std::os::raw::c_char, __stream: *mut FILE) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fopencookie(__magic_cookie: *mut ::std::os::raw::c_void, __modes: *const ::std::os::raw::c_char, __io_funcs: cookie_io_functions_t) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(__s: *mut ::std::os::raw::c_void, __len: size_t, __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(__bufloc: *mut *mut ::std::os::raw::c_char, __sizeloc: *mut size_t) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __modes: ::std::os::raw::c_int, __n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: size_t);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(__stream: *mut FILE, __format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(__s: *mut ::std::os::raw::c_char, __format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(__s: *mut FILE, __format: *const ::std::os::raw::c_char, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(__format: *const ::std::os::raw::c_char, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(__s: *mut ::std::os::raw::c_char, __format: *const ::std::os::raw::c_char, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(__s: *mut ::std::os::raw::c_char, __maxlen: size_t, __format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(__s: *mut ::std::os::raw::c_char, __maxlen: size_t, __format: *const ::std::os::raw::c_char, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(__ptr: *mut *mut ::std::os::raw::c_char, __f: *const ::std::os::raw::c_char, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __asprintf(__ptr: *mut *mut ::std::os::raw::c_char, __fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn asprintf(__ptr: *mut *mut ::std::os::raw::c_char, __fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(__fd: ::std::os::raw::c_int, __fmt: *const ::std::os::raw::c_char, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(__fd: ::std::os::raw::c_int, __fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(__stream: *mut FILE, __format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(__s: *const ::std::os::raw::c_char, __format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(__stream: *mut FILE, __format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(__s: *const ::std::os::raw::c_char, __format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(__s: *mut FILE, __format: *const ::std::os::raw::c_char, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const ::std::os::raw::c_char, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(__s: *const ::std::os::raw::c_char, __format: *const ::std::os::raw::c_char, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(__s: *mut FILE, __format: *const ::std::os::raw::c_char, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(__format: *const ::std::os::raw::c_char, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(__s: *const ::std::os::raw::c_char, __format: *const ::std::os::raw::c_char, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(__s: *mut ::std::os::raw::c_char, __n: ::std::os::raw::c_int, __stream: *mut FILE) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgets_unlocked(__s: *mut ::std::os::raw::c_char, __n: ::std::os::raw::c_int, __stream: *mut FILE) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(__lineptr: *mut *mut ::std::os::raw::c_char, __n: *mut size_t, __delimiter: ::std::os::raw::c_int, __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(__lineptr: *mut *mut ::std::os::raw::c_char, __n: *mut size_t, __delimiter: ::std::os::raw::c_int, __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn getline(__lineptr: *mut *mut ::std::os::raw::c_char, __n: *mut size_t, __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(__ptr: *mut ::std::os::raw::c_void, __size: size_t, __n: size_t, __stream: *mut FILE) -> size_t;
}
extern "C" {
    pub fn fwrite(__ptr: *const ::std::os::raw::c_void, __size: size_t, __n: size_t, __s: *mut FILE) -> size_t;
}
extern "C" {
    pub fn fputs_unlocked(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread_unlocked(__ptr: *mut ::std::os::raw::c_void, __size: size_t, __n: size_t, __stream: *mut FILE) -> size_t;
}
extern "C" {
    pub fn fwrite_unlocked(__ptr: *const ::std::os::raw::c_void, __size: size_t, __n: size_t, __stream: *mut FILE) -> size_t;
}
extern "C" {
    pub fn fseek(__stream: *mut FILE, __off: ::std::os::raw::c_long, __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(__stream: *mut FILE, __off: __off_t, __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseeko64(__stream: *mut FILE, __off: __off64_t, __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello64(__stream: *mut FILE) -> __off64_t;
}
extern "C" {
    pub fn fgetpos64(__stream: *mut FILE, __pos: *mut fpos64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos64(__stream: *mut FILE, __pos: *const fpos64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut _sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut _sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(__command: *const ::std::os::raw::c_char, __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cuserid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obstack {
    _unused: [u8; 0],
}
extern "C" {
    pub fn obstack_printf(__obstack: *mut obstack, __format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn obstack_vprintf(__obstack: *mut obstack, __format: *const ::std::os::raw::c_char, __args: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(__dest: *mut ::std::os::raw::c_void, __src: *const ::std::os::raw::c_void, __n: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(__dest: *mut ::std::os::raw::c_void, __src: *const ::std::os::raw::c_void, __n: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(__dest: *mut ::std::os::raw::c_void, __src: *const ::std::os::raw::c_void, __c: ::std::os::raw::c_int, __n: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(__s: *mut ::std::os::raw::c_void, __c: ::std::os::raw::c_int, __n: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(__s1: *const ::std::os::raw::c_void, __s2: *const ::std::os::raw::c_void, __n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(__s: *mut ::std::os::raw::c_void, __c: ::std::os::raw::c_int, __n: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rawmemchr(__s: *mut ::std::os::raw::c_void, __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memrchr(__s: *mut ::std::os::raw::c_void, __c: ::std::os::raw::c_int, __n: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(__dest: *mut ::std::os::raw::c_char, __src: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(__dest: *mut ::std::os::raw::c_char, __src: *const ::std::os::raw::c_char, __n: size_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(__dest: *mut ::std::os::raw::c_char, __src: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(__dest: *mut ::std::os::raw::c_char, __src: *const ::std::os::raw::c_char, __n: size_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(__s1: *const ::std::os::raw::c_char, __s2: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(__s1: *const ::std::os::raw::c_char, __s2: *const ::std::os::raw::c_char, __n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(__s1: *const ::std::os::raw::c_char, __s2: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(__dest: *mut ::std::os::raw::c_char, __src: *const ::std::os::raw::c_char, __n: size_t) -> size_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(::std::mem::size_of::<__locale_struct>(), 232usize, concat!("Size of: ", stringify!(__locale_struct)));
    assert_eq!(::std::mem::align_of::<__locale_struct>(), 8usize, concat!("Alignment of ", stringify!(__locale_struct)));
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(__locale_struct), "::", stringify!(__locales))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!("Offset of field: ", stringify!(__locale_struct), "::", stringify!(__ctype_b))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!("Offset of field: ", stringify!(__locale_struct), "::", stringify!(__ctype_tolower))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!("Offset of field: ", stringify!(__locale_struct), "::", stringify!(__ctype_toupper))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!("Offset of field: ", stringify!(__locale_struct), "::", stringify!(__names))
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(__s1: *const ::std::os::raw::c_char, __s2: *const ::std::os::raw::c_char, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(__dest: *mut ::std::os::raw::c_char, __src: *const ::std::os::raw::c_char, __n: size_t, __l: locale_t) -> size_t;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(__string: *const ::std::os::raw::c_char, __n: size_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(__s: *mut ::std::os::raw::c_char, __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(__s: *mut ::std::os::raw::c_char, __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchrnul(__s: *mut ::std::os::raw::c_char, __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(__s: *const ::std::os::raw::c_char, __reject: *const ::std::os::raw::c_char) -> size_t;
}
extern "C" {
    pub fn strspn(__s: *const ::std::os::raw::c_char, __accept: *const ::std::os::raw::c_char) -> size_t;
}
extern "C" {
    pub fn strpbrk(__s: *mut ::std::os::raw::c_char, __accept: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(__haystack: *mut ::std::os::raw::c_char, __needle: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(__s: *mut ::std::os::raw::c_char, __delim: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(__s: *mut ::std::os::raw::c_char, __delim: *const ::std::os::raw::c_char, __save_ptr: *mut *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(__s: *mut ::std::os::raw::c_char, __delim: *const ::std::os::raw::c_char, __save_ptr: *mut *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcasestr(__haystack: *mut ::std::os::raw::c_char, __needle: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memmem(__haystack: *const ::std::os::raw::c_void, __haystacklen: size_t, __needle: *const ::std::os::raw::c_void, __needlelen: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __mempcpy(__dest: *mut ::std::os::raw::c_void, __src: *const ::std::os::raw::c_void, __n: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mempcpy(__dest: *mut ::std::os::raw::c_void, __src: *const ::std::os::raw::c_void, __n: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> size_t;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(__errnum: ::std::os::raw::c_int, __buf: *mut ::std::os::raw::c_char, __buflen: size_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_l(__errnum: ::std::os::raw::c_int, __l: locale_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(__s1: *const ::std::os::raw::c_void, __s2: *const ::std::os::raw::c_void, __n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(__src: *const ::std::os::raw::c_void, __dest: *mut ::std::os::raw::c_void, __n: size_t);
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: size_t);
}
extern "C" {
    pub fn index(__s: *const ::std::os::raw::c_char, __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(__s: *const ::std::os::raw::c_char, __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(__s1: *const ::std::os::raw::c_char, __s2: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(__s1: *const ::std::os::raw::c_char, __s2: *const ::std::os::raw::c_char, __n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(__s1: *const ::std::os::raw::c_char, __s2: *const ::std::os::raw::c_char, __loc: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(__s1: *const ::std::os::raw::c_char, __s2: *const ::std::os::raw::c_char, __n: size_t, __loc: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: size_t);
}
extern "C" {
    pub fn strsep(__stringp: *mut *mut ::std::os::raw::c_char, __delim: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(__dest: *mut ::std::os::raw::c_char, __src: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(__dest: *mut ::std::os::raw::c_char, __src: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(__dest: *mut ::std::os::raw::c_char, __src: *const ::std::os::raw::c_char, __n: size_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(__dest: *mut ::std::os::raw::c_char, __src: *const ::std::os::raw::c_char, __n: size_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strverscmp(__s1: *const ::std::os::raw::c_char, __s2: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strfry(__string: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memfrob(__s: *mut ::std::os::raw::c_void, __n: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn basename(__filename: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
pub type DatasetHandle = *mut ::std::os::raw::c_void;
pub type BoosterHandle = *mut ::std::os::raw::c_void;
pub type FastConfigHandle = *mut ::std::os::raw::c_void;
extern "C" {
    #[doc = " \\brief Get string message of the last error."]
    #[doc = " \\return Error information"]
    pub fn LGBM_GetLastError() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\brief Register a callback function for log redirecting."]
    #[doc = " \\param callback The callback function to register"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_RegisterLogCallback(callback: ::std::option::Option<unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char)>) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Load dataset from file (like LightGBM CLI version does)."]
    #[doc = " \\param filename The name of the file"]
    #[doc = " \\param parameters Additional parameters"]
    #[doc = " \\param reference Used to align bin mapper with other dataset, nullptr means isn't used"]
    #[doc = " \\param[out] out A loaded dataset"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetCreateFromFile(
        filename: *const ::std::os::raw::c_char,
        parameters: *const ::std::os::raw::c_char,
        reference: DatasetHandle,
        out: *mut DatasetHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Allocate the space for dataset and bucket feature bins according to sampled data."]
    #[doc = " \\param sample_data Sampled data, grouped by the column"]
    #[doc = " \\param sample_indices Indices of sampled data"]
    #[doc = " \\param ncol Number of columns"]
    #[doc = " \\param num_per_col Size of each sampling column"]
    #[doc = " \\param num_sample_row Number of sampled rows"]
    #[doc = " \\param num_total_row Number of total rows"]
    #[doc = " \\param parameters Additional parameters"]
    #[doc = " \\param[out] out Created dataset"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetCreateFromSampledColumn(
        sample_data: *mut *mut f64,
        sample_indices: *mut *mut ::std::os::raw::c_int,
        ncol: i32,
        num_per_col: *const ::std::os::raw::c_int,
        num_sample_row: i32,
        num_total_row: i32,
        parameters: *const ::std::os::raw::c_char,
        out: *mut DatasetHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Allocate the space for dataset and bucket feature bins according to reference dataset."]
    #[doc = " \\param reference Used to align bin mapper with other dataset"]
    #[doc = " \\param num_total_row Number of total rows"]
    #[doc = " \\param[out] out Created dataset"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetCreateByReference(reference: DatasetHandle, num_total_row: i64, out: *mut DatasetHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Push data to existing dataset, if ``nrow + start_row == num_total_row``, will call ``dataset->FinishLoad``."]
    #[doc = " \\param dataset Handle of dataset"]
    #[doc = " \\param data Pointer to the data space"]
    #[doc = " \\param data_type Type of ``data`` pointer, can be ``C_API_DTYPE_FLOAT32`` or ``C_API_DTYPE_FLOAT64``"]
    #[doc = " \\param nrow Number of rows"]
    #[doc = " \\param ncol Number of columns"]
    #[doc = " \\param start_row Row start index"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetPushRows(
        dataset: DatasetHandle,
        data: *const ::std::os::raw::c_void,
        data_type: ::std::os::raw::c_int,
        nrow: i32,
        ncol: i32,
        start_row: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Push data to existing dataset, if ``nrow + start_row == num_total_row``, will call ``dataset->FinishLoad``."]
    #[doc = " \\param dataset Handle of dataset"]
    #[doc = " \\param indptr Pointer to row headers"]
    #[doc = " \\param indptr_type Type of ``indptr``, can be ``C_API_DTYPE_INT32`` or ``C_API_DTYPE_INT64``"]
    #[doc = " \\param indices Pointer to column indices"]
    #[doc = " \\param data Pointer to the data space"]
    #[doc = " \\param data_type Type of ``data`` pointer, can be ``C_API_DTYPE_FLOAT32`` or ``C_API_DTYPE_FLOAT64``"]
    #[doc = " \\param nindptr Number of rows in the matrix + 1"]
    #[doc = " \\param nelem Number of nonzero elements in the matrix"]
    #[doc = " \\param num_col Number of columns"]
    #[doc = " \\param start_row Row start index"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetPushRowsByCSR(
        dataset: DatasetHandle,
        indptr: *const ::std::os::raw::c_void,
        indptr_type: ::std::os::raw::c_int,
        indices: *const i32,
        data: *const ::std::os::raw::c_void,
        data_type: ::std::os::raw::c_int,
        nindptr: i64,
        nelem: i64,
        num_col: i64,
        start_row: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Create a dataset from CSR format."]
    #[doc = " \\param indptr Pointer to row headers"]
    #[doc = " \\param indptr_type Type of ``indptr``, can be ``C_API_DTYPE_INT32`` or ``C_API_DTYPE_INT64``"]
    #[doc = " \\param indices Pointer to column indices"]
    #[doc = " \\param data Pointer to the data space"]
    #[doc = " \\param data_type Type of ``data`` pointer, can be ``C_API_DTYPE_FLOAT32`` or ``C_API_DTYPE_FLOAT64``"]
    #[doc = " \\param nindptr Number of rows in the matrix + 1"]
    #[doc = " \\param nelem Number of nonzero elements in the matrix"]
    #[doc = " \\param num_col Number of columns"]
    #[doc = " \\param parameters Additional parameters"]
    #[doc = " \\param reference Used to align bin mapper with other dataset, nullptr means isn't used"]
    #[doc = " \\param[out] out Created dataset"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetCreateFromCSR(
        indptr: *const ::std::os::raw::c_void,
        indptr_type: ::std::os::raw::c_int,
        indices: *const i32,
        data: *const ::std::os::raw::c_void,
        data_type: ::std::os::raw::c_int,
        nindptr: i64,
        nelem: i64,
        num_col: i64,
        parameters: *const ::std::os::raw::c_char,
        reference: DatasetHandle,
        out: *mut DatasetHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Create a dataset from CSR format through callbacks."]
    #[doc = " \\param get_row_funptr Pointer to ``std::function<void(int idx, std::vector<std::pair<int, double>>& ret)>``"]
    #[doc = "                       (called for every row and expected to clear and fill ``ret``)"]
    #[doc = " \\param num_rows Number of rows"]
    #[doc = " \\param num_col Number of columns"]
    #[doc = " \\param parameters Additional parameters"]
    #[doc = " \\param reference Used to align bin mapper with other dataset, nullptr means isn't used"]
    #[doc = " \\param[out] out Created dataset"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetCreateFromCSRFunc(
        get_row_funptr: *mut ::std::os::raw::c_void,
        num_rows: ::std::os::raw::c_int,
        num_col: i64,
        parameters: *const ::std::os::raw::c_char,
        reference: DatasetHandle,
        out: *mut DatasetHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Create a dataset from CSC format."]
    #[doc = " \\param col_ptr Pointer to column headers"]
    #[doc = " \\param col_ptr_type Type of ``col_ptr``, can be ``C_API_DTYPE_INT32`` or ``C_API_DTYPE_INT64``"]
    #[doc = " \\param indices Pointer to row indices"]
    #[doc = " \\param data Pointer to the data space"]
    #[doc = " \\param data_type Type of ``data`` pointer, can be ``C_API_DTYPE_FLOAT32`` or ``C_API_DTYPE_FLOAT64``"]
    #[doc = " \\param ncol_ptr Number of columns in the matrix + 1"]
    #[doc = " \\param nelem Number of nonzero elements in the matrix"]
    #[doc = " \\param num_row Number of rows"]
    #[doc = " \\param parameters Additional parameters"]
    #[doc = " \\param reference Used to align bin mapper with other dataset, nullptr means isn't used"]
    #[doc = " \\param[out] out Created dataset"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetCreateFromCSC(
        col_ptr: *const ::std::os::raw::c_void,
        col_ptr_type: ::std::os::raw::c_int,
        indices: *const i32,
        data: *const ::std::os::raw::c_void,
        data_type: ::std::os::raw::c_int,
        ncol_ptr: i64,
        nelem: i64,
        num_row: i64,
        parameters: *const ::std::os::raw::c_char,
        reference: DatasetHandle,
        out: *mut DatasetHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Create dataset from dense matrix."]
    #[doc = " \\param data Pointer to the data space"]
    #[doc = " \\param data_type Type of ``data`` pointer, can be ``C_API_DTYPE_FLOAT32`` or ``C_API_DTYPE_FLOAT64``"]
    #[doc = " \\param nrow Number of rows"]
    #[doc = " \\param ncol Number of columns"]
    #[doc = " \\param is_row_major 1 for row-major, 0 for column-major"]
    #[doc = " \\param parameters Additional parameters"]
    #[doc = " \\param reference Used to align bin mapper with other dataset, nullptr means isn't used"]
    #[doc = " \\param[out] out Created dataset"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetCreateFromMat(
        data: *const ::std::os::raw::c_void,
        data_type: ::std::os::raw::c_int,
        nrow: i32,
        ncol: i32,
        is_row_major: ::std::os::raw::c_int,
        parameters: *const ::std::os::raw::c_char,
        reference: DatasetHandle,
        out: *mut DatasetHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Create dataset from array of dense matrices."]
    #[doc = " \\param nmat Number of dense matrices"]
    #[doc = " \\param data Pointer to the data space"]
    #[doc = " \\param data_type Type of ``data`` pointer, can be ``C_API_DTYPE_FLOAT32`` or ``C_API_DTYPE_FLOAT64``"]
    #[doc = " \\param nrow Number of rows"]
    #[doc = " \\param ncol Number of columns"]
    #[doc = " \\param is_row_major 1 for row-major, 0 for column-major"]
    #[doc = " \\param parameters Additional parameters"]
    #[doc = " \\param reference Used to align bin mapper with other dataset, nullptr means isn't used"]
    #[doc = " \\param[out] out Created dataset"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetCreateFromMats(
        nmat: i32,
        data: *mut *const ::std::os::raw::c_void,
        data_type: ::std::os::raw::c_int,
        nrow: *mut i32,
        ncol: i32,
        is_row_major: ::std::os::raw::c_int,
        parameters: *const ::std::os::raw::c_char,
        reference: DatasetHandle,
        out: *mut DatasetHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Create subset of a data."]
    #[doc = " \\param handle Handle of full dataset"]
    #[doc = " \\param used_row_indices Indices used in subset"]
    #[doc = " \\param num_used_row_indices Length of ``used_row_indices``"]
    #[doc = " \\param parameters Additional parameters"]
    #[doc = " \\param[out] out Subset of data"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetGetSubset(
        handle: DatasetHandle,
        used_row_indices: *const i32,
        num_used_row_indices: i32,
        parameters: *const ::std::os::raw::c_char,
        out: *mut DatasetHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Save feature names to dataset."]
    #[doc = " \\param handle Handle of dataset"]
    #[doc = " \\param feature_names Feature names"]
    #[doc = " \\param num_feature_names Number of feature names"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetSetFeatureNames(handle: DatasetHandle, feature_names: *mut *const ::std::os::raw::c_char, num_feature_names: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get feature names of dataset."]
    #[doc = " \\param handle Handle of dataset"]
    #[doc = " \\param len Number of ``char*`` pointers stored at ``out_strs``."]
    #[doc = "            If smaller than the max size, only this many strings are copied"]
    #[doc = " \\param[out] num_feature_names Number of feature names"]
    #[doc = " \\param buffer_len Size of pre-allocated strings."]
    #[doc = "                   Content is copied up to ``buffer_len - 1`` and null-terminated"]
    #[doc = " \\param[out] out_buffer_len String sizes required to do the full string copies"]
    #[doc = " \\param[out] feature_names Feature names, should pre-allocate memory"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetGetFeatureNames(
        handle: DatasetHandle,
        len: ::std::os::raw::c_int,
        num_feature_names: *mut ::std::os::raw::c_int,
        buffer_len: size_t,
        out_buffer_len: *mut size_t,
        feature_names: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Free space for dataset."]
    #[doc = " \\param handle Handle of dataset to be freed"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetFree(handle: DatasetHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Save dataset to binary file."]
    #[doc = " \\param handle Handle of dataset"]
    #[doc = " \\param filename The name of the file"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetSaveBinary(handle: DatasetHandle, filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Save dataset to text file, intended for debugging use only."]
    #[doc = " \\param handle Handle of dataset"]
    #[doc = " \\param filename The name of the file"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetDumpText(handle: DatasetHandle, filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set vector to a content in info."]
    #[doc = " \\note"]
    #[doc = " - \\a group only works for ``C_API_DTYPE_INT32``;"]
    #[doc = " - \\a label and \\a weight only work for ``C_API_DTYPE_FLOAT32``;"]
    #[doc = " - \\a init_score only works for ``C_API_DTYPE_FLOAT64``."]
    #[doc = " \\param handle Handle of dataset"]
    #[doc = " \\param field_name Field name, can be \\a label, \\a weight, \\a init_score, \\a group"]
    #[doc = " \\param field_data Pointer to data vector"]
    #[doc = " \\param num_element Number of elements in ``field_data``"]
    #[doc = " \\param type Type of ``field_data`` pointer, can be ``C_API_DTYPE_INT32``, ``C_API_DTYPE_FLOAT32`` or ``C_API_DTYPE_FLOAT64``"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetSetField(
        handle: DatasetHandle,
        field_name: *const ::std::os::raw::c_char,
        field_data: *const ::std::os::raw::c_void,
        num_element: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get info vector from dataset."]
    #[doc = " \\param handle Handle of dataset"]
    #[doc = " \\param field_name Field name"]
    #[doc = " \\param[out] out_len Used to set result length"]
    #[doc = " \\param[out] out_ptr Pointer to the result"]
    #[doc = " \\param[out] out_type Type of result pointer, can be ``C_API_DTYPE_INT32``, ``C_API_DTYPE_FLOAT32`` or ``C_API_DTYPE_FLOAT64``"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetGetField(
        handle: DatasetHandle,
        field_name: *const ::std::os::raw::c_char,
        out_len: *mut ::std::os::raw::c_int,
        out_ptr: *mut *const ::std::os::raw::c_void,
        out_type: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Raise errors for attempts to update dataset parameters."]
    #[doc = " \\param old_parameters Current dataset parameters"]
    #[doc = " \\param new_parameters New dataset parameters"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetUpdateParamChecking(old_parameters: *const ::std::os::raw::c_char, new_parameters: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get number of data points."]
    #[doc = " \\param handle Handle of dataset"]
    #[doc = " \\param[out] out The address to hold number of data points"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetGetNumData(handle: DatasetHandle, out: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get number of features."]
    #[doc = " \\param handle Handle of dataset"]
    #[doc = " \\param[out] out The address to hold number of features"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetGetNumFeature(handle: DatasetHandle, out: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Add features from ``source`` to ``target``."]
    #[doc = " \\param target The handle of the dataset to add features to"]
    #[doc = " \\param source The handle of the dataset to take features from"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_DatasetAddFeaturesFrom(target: DatasetHandle, source: DatasetHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get boolean representing whether booster is fitting linear trees."]
    #[doc = " \\param handle Handle of booster"]
    #[doc = " \\param[out] out The address to hold linear trees indicator"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterGetLinear(handle: BoosterHandle, out: *mut bool) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Create a new boosting learner."]
    #[doc = " \\param train_data Training dataset"]
    #[doc = " \\param parameters Parameters in format 'key1=value1 key2=value2'"]
    #[doc = " \\param[out] out Handle of created booster"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterCreate(train_data: DatasetHandle, parameters: *const ::std::os::raw::c_char, out: *mut BoosterHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Load an existing booster from model file."]
    #[doc = " \\param filename Filename of model"]
    #[doc = " \\param[out] out_num_iterations Number of iterations of this booster"]
    #[doc = " \\param[out] out Handle of created booster"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterCreateFromModelfile(
        filename: *const ::std::os::raw::c_char,
        out_num_iterations: *mut ::std::os::raw::c_int,
        out: *mut BoosterHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Load an existing booster from string."]
    #[doc = " \\param model_str Model string"]
    #[doc = " \\param[out] out_num_iterations Number of iterations of this booster"]
    #[doc = " \\param[out] out Handle of created booster"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterLoadModelFromString(
        model_str: *const ::std::os::raw::c_char,
        out_num_iterations: *mut ::std::os::raw::c_int,
        out: *mut BoosterHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Free space for booster."]
    #[doc = " \\param handle Handle of booster to be freed"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterFree(handle: BoosterHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Shuffle models."]
    #[doc = " \\param handle Handle of booster"]
    #[doc = " \\param start_iter The first iteration that will be shuffled"]
    #[doc = " \\param end_iter The last iteration that will be shuffled"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterShuffleModels(handle: BoosterHandle, start_iter: ::std::os::raw::c_int, end_iter: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Merge model from ``other_handle`` into ``handle``."]
    #[doc = " \\param handle Handle of booster, will merge another booster into this one"]
    #[doc = " \\param other_handle Other handle of booster"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterMerge(handle: BoosterHandle, other_handle: BoosterHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Add new validation data to booster."]
    #[doc = " \\param handle Handle of booster"]
    #[doc = " \\param valid_data Validation dataset"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterAddValidData(handle: BoosterHandle, valid_data: DatasetHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reset training data for booster."]
    #[doc = " \\param handle Handle of booster"]
    #[doc = " \\param train_data Training dataset"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterResetTrainingData(handle: BoosterHandle, train_data: DatasetHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reset config for booster."]
    #[doc = " \\param handle Handle of booster"]
    #[doc = " \\param parameters Parameters in format 'key1=value1 key2=value2'"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterResetParameter(handle: BoosterHandle, parameters: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get number of classes."]
    #[doc = " \\param handle Handle of booster"]
    #[doc = " \\param[out] out_len Number of classes"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterGetNumClasses(handle: BoosterHandle, out_len: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Update the model for one iteration."]
    #[doc = " \\param handle Handle of booster"]
    #[doc = " \\param[out] is_finished 1 means the update was successfully finished (cannot split any more), 0 indicates failure"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterUpdateOneIter(handle: BoosterHandle, is_finished: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Refit the tree model using the new data (online learning)."]
    #[doc = " \\param handle Handle of booster"]
    #[doc = " \\param leaf_preds Pointer to predicted leaf indices"]
    #[doc = " \\param nrow Number of rows of ``leaf_preds``"]
    #[doc = " \\param ncol Number of columns of ``leaf_preds``"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterRefit(handle: BoosterHandle, leaf_preds: *const i32, nrow: i32, ncol: i32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Update the model by specifying gradient and Hessian directly"]
    #[doc = "        (this can be used to support customized loss functions)."]
    #[doc = " \\param handle Handle of booster"]
    #[doc = " \\param grad The first order derivative (gradient) statistics"]
    #[doc = " \\param hess The second order derivative (Hessian) statistics"]
    #[doc = " \\param[out] is_finished 1 means the update was successfully finished (cannot split any more), 0 indicates failure"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterUpdateOneIterCustom(handle: BoosterHandle, grad: *const f32, hess: *const f32, is_finished: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Rollback one iteration."]
    #[doc = " \\param handle Handle of booster"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterRollbackOneIter(handle: BoosterHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get index of the current boosting iteration."]
    #[doc = " \\param handle Handle of booster"]
    #[doc = " \\param[out] out_iteration Index of the current boosting iteration"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterGetCurrentIteration(handle: BoosterHandle, out_iteration: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get number of trees per iteration."]
    #[doc = " \\param handle Handle of booster"]
    #[doc = " \\param[out] out_tree_per_iteration Number of trees per iteration"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterNumModelPerIteration(handle: BoosterHandle, out_tree_per_iteration: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get number of weak sub-models."]
    #[doc = " \\param handle Handle of booster"]
    #[doc = " \\param[out] out_models Number of weak sub-models"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterNumberOfTotalModel(handle: BoosterHandle, out_models: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get number of evaluation datasets."]
    #[doc = " \\param handle Handle of booster"]
    #[doc = " \\param[out] out_len Total number of evaluation datasets"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterGetEvalCounts(handle: BoosterHandle, out_len: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get names of evaluation datasets."]
    #[doc = " \\param handle Handle of booster"]
    #[doc = " \\param len Number of ``char*`` pointers stored at ``out_strs``."]
    #[doc = "            If smaller than the max size, only this many strings are copied"]
    #[doc = " \\param[out] out_len Total number of evaluation datasets"]
    #[doc = " \\param buffer_len Size of pre-allocated strings."]
    #[doc = "                   Content is copied up to ``buffer_len - 1`` and null-terminated"]
    #[doc = " \\param[out] out_buffer_len String sizes required to do the full string copies"]
    #[doc = " \\param[out] out_strs Names of evaluation datasets, should pre-allocate memory"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterGetEvalNames(
        handle: BoosterHandle,
        len: ::std::os::raw::c_int,
        out_len: *mut ::std::os::raw::c_int,
        buffer_len: size_t,
        out_buffer_len: *mut size_t,
        out_strs: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get names of features."]
    #[doc = " \\param handle Handle of booster"]
    #[doc = " \\param len Number of ``char*`` pointers stored at ``out_strs``."]
    #[doc = "            If smaller than the max size, only this many strings are copied"]
    #[doc = " \\param[out] out_len Total number of features"]
    #[doc = " \\param buffer_len Size of pre-allocated strings."]
    #[doc = "                   Content is copied up to ``buffer_len - 1`` and null-terminated"]
    #[doc = " \\param[out] out_buffer_len String sizes required to do the full string copies"]
    #[doc = " \\param[out] out_strs Names of features, should pre-allocate memory"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterGetFeatureNames(
        handle: BoosterHandle,
        len: ::std::os::raw::c_int,
        out_len: *mut ::std::os::raw::c_int,
        buffer_len: size_t,
        out_buffer_len: *mut size_t,
        out_strs: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get number of features."]
    #[doc = " \\param handle Handle of booster"]
    #[doc = " \\param[out] out_len Total number of features"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterGetNumFeature(handle: BoosterHandle, out_len: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get evaluation for training data and validation data."]
    #[doc = " \\note"]
    #[doc = "   1. You should call ``LGBM_BoosterGetEvalNames`` first to get the names of evaluation datasets."]
    #[doc = "   2. You should pre-allocate memory for ``out_results``, you can get its length by ``LGBM_BoosterGetEvalCounts``."]
    #[doc = " \\param handle Handle of booster"]
    #[doc = " \\param data_idx Index of data, 0: training data, 1: 1st validation data, 2: 2nd validation data and so on"]
    #[doc = " \\param[out] out_len Length of output result"]
    #[doc = " \\param[out] out_results Array with evaluation results"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterGetEval(handle: BoosterHandle, data_idx: ::std::os::raw::c_int, out_len: *mut ::std::os::raw::c_int, out_results: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get number of predictions for training data and validation data"]
    #[doc = "        (this can be used to support customized evaluation functions)."]
    #[doc = " \\param handle Handle of booster"]
    #[doc = " \\param data_idx Index of data, 0: training data, 1: 1st validation data, 2: 2nd validation data and so on"]
    #[doc = " \\param[out] out_len Number of predictions"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterGetNumPredict(handle: BoosterHandle, data_idx: ::std::os::raw::c_int, out_len: *mut i64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get prediction for training data and validation data."]
    #[doc = " \\note"]
    #[doc = " You should pre-allocate memory for ``out_result``, its length is equal to ``num_class * num_data``."]
    #[doc = " \\param handle Handle of booster"]
    #[doc = " \\param data_idx Index of data, 0: training data, 1: 1st validation data, 2: 2nd validation data and so on"]
    #[doc = " \\param[out] out_len Length of output result"]
    #[doc = " \\param[out] out_result Pointer to array with predictions"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterGetPredict(handle: BoosterHandle, data_idx: ::std::os::raw::c_int, out_len: *mut i64, out_result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Make prediction for file."]
    #[doc = " \\param handle Handle of booster"]
    #[doc = " \\param data_filename Filename of file with data"]
    #[doc = " \\param data_has_header Whether file has header or not"]
    #[doc = " \\param predict_type What should be predicted"]
    #[doc = "   - ``C_API_PREDICT_NORMAL``: normal prediction, with transform (if needed);"]
    #[doc = "   - ``C_API_PREDICT_RAW_SCORE``: raw score;"]
    #[doc = "   - ``C_API_PREDICT_LEAF_INDEX``: leaf index;"]
    #[doc = "   - ``C_API_PREDICT_CONTRIB``: feature contributions (SHAP values)"]
    #[doc = " \\param start_iteration Start index of the iteration to predict"]
    #[doc = " \\param num_iteration Number of iterations for prediction, <= 0 means no limit"]
    #[doc = " \\param parameter Other parameters for prediction, e.g. early stopping for prediction"]
    #[doc = " \\param result_filename Filename of result file in which predictions will be written"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterPredictForFile(
        handle: BoosterHandle,
        data_filename: *const ::std::os::raw::c_char,
        data_has_header: ::std::os::raw::c_int,
        predict_type: ::std::os::raw::c_int,
        start_iteration: ::std::os::raw::c_int,
        num_iteration: ::std::os::raw::c_int,
        parameter: *const ::std::os::raw::c_char,
        result_filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get number of predictions."]
    #[doc = " \\param handle Handle of booster"]
    #[doc = " \\param num_row Number of rows"]
    #[doc = " \\param predict_type What should be predicted"]
    #[doc = "   - ``C_API_PREDICT_NORMAL``: normal prediction, with transform (if needed);"]
    #[doc = "   - ``C_API_PREDICT_RAW_SCORE``: raw score;"]
    #[doc = "   - ``C_API_PREDICT_LEAF_INDEX``: leaf index;"]
    #[doc = "   - ``C_API_PREDICT_CONTRIB``: feature contributions (SHAP values)"]
    #[doc = " \\param start_iteration Start index of the iteration to predict"]
    #[doc = " \\param num_iteration Number of iterations for prediction, <= 0 means no limit"]
    #[doc = " \\param[out] out_len Length of prediction"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterCalcNumPredict(
        handle: BoosterHandle,
        num_row: ::std::os::raw::c_int,
        predict_type: ::std::os::raw::c_int,
        start_iteration: ::std::os::raw::c_int,
        num_iteration: ::std::os::raw::c_int,
        out_len: *mut i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Release FastConfig object."]
    #[doc = ""]
    #[doc = " \\param fastConfig Handle to the FastConfig object acquired with a ``*FastInit()`` method."]
    #[doc = " \\return 0 when it succeeds, -1 when failure happens"]
    pub fn LGBM_FastConfigFree(fastConfig: FastConfigHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Make prediction for a new dataset in CSR format."]
    #[doc = " \\note"]
    #[doc = " You should pre-allocate memory for ``out_result``:"]
    #[doc = "   - for normal and raw score, its length is equal to ``num_class * num_data``;"]
    #[doc = "   - for leaf index, its length is equal to ``num_class * num_data * num_iteration``;"]
    #[doc = "   - for feature contributions, its length is equal to ``num_class * num_data * (num_feature + 1)``."]
    #[doc = " \\param handle Handle of booster"]
    #[doc = " \\param indptr Pointer to row headers"]
    #[doc = " \\param indptr_type Type of ``indptr``, can be ``C_API_DTYPE_INT32`` or ``C_API_DTYPE_INT64``"]
    #[doc = " \\param indices Pointer to column indices"]
    #[doc = " \\param data Pointer to the data space"]
    #[doc = " \\param data_type Type of ``data`` pointer, can be ``C_API_DTYPE_FLOAT32`` or ``C_API_DTYPE_FLOAT64``"]
    #[doc = " \\param nindptr Number of rows in the matrix + 1"]
    #[doc = " \\param nelem Number of nonzero elements in the matrix"]
    #[doc = " \\param num_col Number of columns"]
    #[doc = " \\param predict_type What should be predicted"]
    #[doc = "   - ``C_API_PREDICT_NORMAL``: normal prediction, with transform (if needed);"]
    #[doc = "   - ``C_API_PREDICT_RAW_SCORE``: raw score;"]
    #[doc = "   - ``C_API_PREDICT_LEAF_INDEX``: leaf index;"]
    #[doc = "   - ``C_API_PREDICT_CONTRIB``: feature contributions (SHAP values)"]
    #[doc = " \\param start_iteration Start index of the iteration to predict"]
    #[doc = " \\param num_iteration Number of iterations for prediction, <= 0 means no limit"]
    #[doc = " \\param parameter Other parameters for prediction, e.g. early stopping for prediction"]
    #[doc = " \\param[out] out_len Length of output result"]
    #[doc = " \\param[out] out_result Pointer to array with predictions"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterPredictForCSR(
        handle: BoosterHandle,
        indptr: *const ::std::os::raw::c_void,
        indptr_type: ::std::os::raw::c_int,
        indices: *const i32,
        data: *const ::std::os::raw::c_void,
        data_type: ::std::os::raw::c_int,
        nindptr: i64,
        nelem: i64,
        num_col: i64,
        predict_type: ::std::os::raw::c_int,
        start_iteration: ::std::os::raw::c_int,
        num_iteration: ::std::os::raw::c_int,
        parameter: *const ::std::os::raw::c_char,
        out_len: *mut i64,
        out_result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Make sparse prediction for a new dataset in CSR or CSC format. Currently only used for feature contributions."]
    #[doc = " \\note"]
    #[doc = " The outputs are pre-allocated, as they can vary for each invocation, but the shape should be the same:"]
    #[doc = "   - for feature contributions, the shape of sparse matrix will be ``num_class * num_data * (num_feature + 1)``."]
    #[doc = " The output indptr_type for the sparse matrix will be the same as the given input indptr_type."]
    #[doc = " Call ``LGBM_BoosterFreePredictSparse`` to deallocate resources."]
    #[doc = " \\param handle Handle of booster"]
    #[doc = " \\param indptr Pointer to row headers for CSR or column headers for CSC"]
    #[doc = " \\param indptr_type Type of ``indptr``, can be ``C_API_DTYPE_INT32`` or ``C_API_DTYPE_INT64``"]
    #[doc = " \\param indices Pointer to column indices for CSR or row indices for CSC"]
    #[doc = " \\param data Pointer to the data space"]
    #[doc = " \\param data_type Type of ``data`` pointer, can be ``C_API_DTYPE_FLOAT32`` or ``C_API_DTYPE_FLOAT64``"]
    #[doc = " \\param nindptr Number of rows in the matrix + 1"]
    #[doc = " \\param nelem Number of nonzero elements in the matrix"]
    #[doc = " \\param num_col_or_row Number of columns for CSR or number of rows for CSC"]
    #[doc = " \\param predict_type What should be predicted, only feature contributions supported currently"]
    #[doc = "   - ``C_API_PREDICT_CONTRIB``: feature contributions (SHAP values)"]
    #[doc = " \\param start_iteration Start index of the iteration to predict"]
    #[doc = " \\param num_iteration Number of iterations for prediction, <= 0 means no limit"]
    #[doc = " \\param parameter Other parameters for prediction, e.g. early stopping for prediction"]
    #[doc = " \\param matrix_type Type of matrix input and output, can be ``C_API_MATRIX_TYPE_CSR`` or ``C_API_MATRIX_TYPE_CSC``"]
    #[doc = " \\param[out] out_len Length of output indices and data"]
    #[doc = " \\param[out] out_indptr Pointer to output row headers for CSR or column headers for CSC"]
    #[doc = " \\param[out] out_indices Pointer to sparse column indices for CSR or row indices for CSC"]
    #[doc = " \\param[out] out_data Pointer to sparse data space"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterPredictSparseOutput(
        handle: BoosterHandle,
        indptr: *const ::std::os::raw::c_void,
        indptr_type: ::std::os::raw::c_int,
        indices: *const i32,
        data: *const ::std::os::raw::c_void,
        data_type: ::std::os::raw::c_int,
        nindptr: i64,
        nelem: i64,
        num_col_or_row: i64,
        predict_type: ::std::os::raw::c_int,
        start_iteration: ::std::os::raw::c_int,
        num_iteration: ::std::os::raw::c_int,
        parameter: *const ::std::os::raw::c_char,
        matrix_type: ::std::os::raw::c_int,
        out_len: *mut i64,
        out_indptr: *mut *mut ::std::os::raw::c_void,
        out_indices: *mut *mut i32,
        out_data: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Method corresponding to ``LGBM_BoosterPredictSparseOutput`` to free the allocated data."]
    #[doc = " \\param indptr Pointer to output row headers or column headers to be deallocated"]
    #[doc = " \\param indices Pointer to sparse indices to be deallocated"]
    #[doc = " \\param data Pointer to sparse data space to be deallocated"]
    #[doc = " \\param indptr_type Type of ``indptr``, can be ``C_API_DTYPE_INT32`` or ``C_API_DTYPE_INT64``"]
    #[doc = " \\param data_type Type of ``data`` pointer, can be ``C_API_DTYPE_FLOAT32`` or ``C_API_DTYPE_FLOAT64``"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterFreePredictSparse(
        indptr: *mut ::std::os::raw::c_void,
        indices: *mut i32,
        data: *mut ::std::os::raw::c_void,
        indptr_type: ::std::os::raw::c_int,
        data_type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Make prediction for a new dataset in CSR format. This method re-uses the internal predictor structure"]
    #[doc = "        from previous calls and is optimized for single row invocation."]
    #[doc = " \\note"]
    #[doc = " You should pre-allocate memory for ``out_result``:"]
    #[doc = "   - for normal and raw score, its length is equal to ``num_class * num_data``;"]
    #[doc = "   - for leaf index, its length is equal to ``num_class * num_data * num_iteration``;"]
    #[doc = "   - for feature contributions, its length is equal to ``num_class * num_data * (num_feature + 1)``."]
    #[doc = " \\param handle Handle of booster"]
    #[doc = " \\param indptr Pointer to row headers"]
    #[doc = " \\param indptr_type Type of ``indptr``, can be ``C_API_DTYPE_INT32`` or ``C_API_DTYPE_INT64``"]
    #[doc = " \\param indices Pointer to column indices"]
    #[doc = " \\param data Pointer to the data space"]
    #[doc = " \\param data_type Type of ``data`` pointer, can be ``C_API_DTYPE_FLOAT32`` or ``C_API_DTYPE_FLOAT64``"]
    #[doc = " \\param nindptr Number of rows in the matrix + 1"]
    #[doc = " \\param nelem Number of nonzero elements in the matrix"]
    #[doc = " \\param num_col Number of columns"]
    #[doc = " \\param predict_type What should be predicted"]
    #[doc = "   - ``C_API_PREDICT_NORMAL``: normal prediction, with transform (if needed);"]
    #[doc = "   - ``C_API_PREDICT_RAW_SCORE``: raw score;"]
    #[doc = "   - ``C_API_PREDICT_LEAF_INDEX``: leaf index;"]
    #[doc = "   - ``C_API_PREDICT_CONTRIB``: feature contributions (SHAP values)"]
    #[doc = " \\param start_iteration Start index of the iteration to predict"]
    #[doc = " \\param num_iteration Number of iterations for prediction, <= 0 means no limit"]
    #[doc = " \\param parameter Other parameters for prediction, e.g. early stopping for prediction"]
    #[doc = " \\param[out] out_len Length of output result"]
    #[doc = " \\param[out] out_result Pointer to array with predictions"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterPredictForCSRSingleRow(
        handle: BoosterHandle,
        indptr: *const ::std::os::raw::c_void,
        indptr_type: ::std::os::raw::c_int,
        indices: *const i32,
        data: *const ::std::os::raw::c_void,
        data_type: ::std::os::raw::c_int,
        nindptr: i64,
        nelem: i64,
        num_col: i64,
        predict_type: ::std::os::raw::c_int,
        start_iteration: ::std::os::raw::c_int,
        num_iteration: ::std::os::raw::c_int,
        parameter: *const ::std::os::raw::c_char,
        out_len: *mut i64,
        out_result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Initialize and return a ``FastConfigHandle`` for use with ``LGBM_BoosterPredictForCSRSingleRowFast``."]
    #[doc = ""]
    #[doc = " Release the ``FastConfig`` by passing its handle to ``LGBM_FastConfigFree`` when no longer needed."]
    #[doc = ""]
    #[doc = " \\param handle Booster handle"]
    #[doc = " \\param predict_type What should be predicted"]
    #[doc = "   - ``C_API_PREDICT_NORMAL``: normal prediction, with transform (if needed);"]
    #[doc = "   - ``C_API_PREDICT_RAW_SCORE``: raw score;"]
    #[doc = "   - ``C_API_PREDICT_LEAF_INDEX``: leaf index;"]
    #[doc = "   - ``C_API_PREDICT_CONTRIB``: feature contributions (SHAP values)"]
    #[doc = " \\param start_iteration Start index of the iteration to predict"]
    #[doc = " \\param num_iteration Number of iterations for prediction, <= 0 means no limit"]
    #[doc = " \\param data_type Type of ``data`` pointer, can be ``C_API_DTYPE_FLOAT32`` or ``C_API_DTYPE_FLOAT64``"]
    #[doc = " \\param num_col Number of columns"]
    #[doc = " \\param parameter Other parameters for prediction, e.g. early stopping for prediction"]
    #[doc = " \\param[out] out_fastConfig FastConfig object with which you can call ``LGBM_BoosterPredictForCSRSingleRowFast``"]
    #[doc = " \\return 0 when it succeeds, -1 when failure happens"]
    pub fn LGBM_BoosterPredictForCSRSingleRowFastInit(
        handle: BoosterHandle,
        predict_type: ::std::os::raw::c_int,
        start_iteration: ::std::os::raw::c_int,
        num_iteration: ::std::os::raw::c_int,
        data_type: ::std::os::raw::c_int,
        num_col: i64,
        parameter: *const ::std::os::raw::c_char,
        out_fastConfig: *mut FastConfigHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Faster variant of ``LGBM_BoosterPredictForCSRSingleRow``."]
    #[doc = ""]
    #[doc = " Score single rows after setup with ``LGBM_BoosterPredictForCSRSingleRowFastInit``."]
    #[doc = ""]
    #[doc = " By removing the setup steps from this call extra optimizations can be made like"]
    #[doc = " initializing the config only once, instead of once per call."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = "   Setting up the number of threads is only done once at ``LGBM_BoosterPredictForCSRSingleRowFastInit``"]
    #[doc = "   instead of at each prediction."]
    #[doc = "   If you use a different number of threads in other calls, you need to start the setup process over,"]
    #[doc = "   or that number of threads will be used for these calls as well."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " You should pre-allocate memory for ``out_result``:"]
    #[doc = "   - for normal and raw score, its length is equal to ``num_class * num_data``;"]
    #[doc = "   - for leaf index, its length is equal to ``num_class * num_data * num_iteration``;"]
    #[doc = "   - for feature contributions, its length is equal to ``num_class * num_data * (num_feature + 1)``."]
    #[doc = ""]
    #[doc = " \\param fastConfig_handle FastConfig object handle returned by ``LGBM_BoosterPredictForCSRSingleRowFastInit``"]
    #[doc = " \\param indptr Pointer to row headers"]
    #[doc = " \\param indptr_type Type of ``indptr``, can be ``C_API_DTYPE_INT32`` or ``C_API_DTYPE_INT64``"]
    #[doc = " \\param indices Pointer to column indices"]
    #[doc = " \\param data Pointer to the data space"]
    #[doc = " \\param nindptr Number of rows in the matrix + 1"]
    #[doc = " \\param nelem Number of nonzero elements in the matrix"]
    #[doc = " \\param[out] out_len Length of output result"]
    #[doc = " \\param[out] out_result Pointer to array with predictions"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterPredictForCSRSingleRowFast(
        fastConfig_handle: FastConfigHandle,
        indptr: *const ::std::os::raw::c_void,
        indptr_type: ::std::os::raw::c_int,
        indices: *const i32,
        data: *const ::std::os::raw::c_void,
        nindptr: i64,
        nelem: i64,
        out_len: *mut i64,
        out_result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Make prediction for a new dataset in CSC format."]
    #[doc = " \\note"]
    #[doc = " You should pre-allocate memory for ``out_result``:"]
    #[doc = "   - for normal and raw score, its length is equal to ``num_class * num_data``;"]
    #[doc = "   - for leaf index, its length is equal to ``num_class * num_data * num_iteration``;"]
    #[doc = "   - for feature contributions, its length is equal to ``num_class * num_data * (num_feature + 1)``."]
    #[doc = " \\param handle Handle of booster"]
    #[doc = " \\param col_ptr Pointer to column headers"]
    #[doc = " \\param col_ptr_type Type of ``col_ptr``, can be ``C_API_DTYPE_INT32`` or ``C_API_DTYPE_INT64``"]
    #[doc = " \\param indices Pointer to row indices"]
    #[doc = " \\param data Pointer to the data space"]
    #[doc = " \\param data_type Type of ``data`` pointer, can be ``C_API_DTYPE_FLOAT32`` or ``C_API_DTYPE_FLOAT64``"]
    #[doc = " \\param ncol_ptr Number of columns in the matrix + 1"]
    #[doc = " \\param nelem Number of nonzero elements in the matrix"]
    #[doc = " \\param num_row Number of rows"]
    #[doc = " \\param predict_type What should be predicted"]
    #[doc = "   - ``C_API_PREDICT_NORMAL``: normal prediction, with transform (if needed);"]
    #[doc = "   - ``C_API_PREDICT_RAW_SCORE``: raw score;"]
    #[doc = "   - ``C_API_PREDICT_LEAF_INDEX``: leaf index;"]
    #[doc = "   - ``C_API_PREDICT_CONTRIB``: feature contributions (SHAP values)"]
    #[doc = " \\param start_iteration Start index of the iteration to predict"]
    #[doc = " \\param num_iteration Number of iteration for prediction, <= 0 means no limit"]
    #[doc = " \\param parameter Other parameters for prediction, e.g. early stopping for prediction"]
    #[doc = " \\param[out] out_len Length of output result"]
    #[doc = " \\param[out] out_result Pointer to array with predictions"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterPredictForCSC(
        handle: BoosterHandle,
        col_ptr: *const ::std::os::raw::c_void,
        col_ptr_type: ::std::os::raw::c_int,
        indices: *const i32,
        data: *const ::std::os::raw::c_void,
        data_type: ::std::os::raw::c_int,
        ncol_ptr: i64,
        nelem: i64,
        num_row: i64,
        predict_type: ::std::os::raw::c_int,
        start_iteration: ::std::os::raw::c_int,
        num_iteration: ::std::os::raw::c_int,
        parameter: *const ::std::os::raw::c_char,
        out_len: *mut i64,
        out_result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Make prediction for a new dataset."]
    #[doc = " \\note"]
    #[doc = " You should pre-allocate memory for ``out_result``:"]
    #[doc = "   - for normal and raw score, its length is equal to ``num_class * num_data``;"]
    #[doc = "   - for leaf index, its length is equal to ``num_class * num_data * num_iteration``;"]
    #[doc = "   - for feature contributions, its length is equal to ``num_class * num_data * (num_feature + 1)``."]
    #[doc = " \\param handle Handle of booster"]
    #[doc = " \\param data Pointer to the data space"]
    #[doc = " \\param data_type Type of ``data`` pointer, can be ``C_API_DTYPE_FLOAT32`` or ``C_API_DTYPE_FLOAT64``"]
    #[doc = " \\param nrow Number of rows"]
    #[doc = " \\param ncol Number of columns"]
    #[doc = " \\param is_row_major 1 for row-major, 0 for column-major"]
    #[doc = " \\param predict_type What should be predicted"]
    #[doc = "   - ``C_API_PREDICT_NORMAL``: normal prediction, with transform (if needed);"]
    #[doc = "   - ``C_API_PREDICT_RAW_SCORE``: raw score;"]
    #[doc = "   - ``C_API_PREDICT_LEAF_INDEX``: leaf index;"]
    #[doc = "   - ``C_API_PREDICT_CONTRIB``: feature contributions (SHAP values)"]
    #[doc = " \\param start_iteration Start index of the iteration to predict"]
    #[doc = " \\param num_iteration Number of iteration for prediction, <= 0 means no limit"]
    #[doc = " \\param parameter Other parameters for prediction, e.g. early stopping for prediction"]
    #[doc = " \\param[out] out_len Length of output result"]
    #[doc = " \\param[out] out_result Pointer to array with predictions"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterPredictForMat(
        handle: BoosterHandle,
        data: *const ::std::os::raw::c_void,
        data_type: ::std::os::raw::c_int,
        nrow: i32,
        ncol: i32,
        is_row_major: ::std::os::raw::c_int,
        predict_type: ::std::os::raw::c_int,
        start_iteration: ::std::os::raw::c_int,
        num_iteration: ::std::os::raw::c_int,
        parameter: *const ::std::os::raw::c_char,
        out_len: *mut i64,
        out_result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Make prediction for a new dataset. This method re-uses the internal predictor structure"]
    #[doc = "        from previous calls and is optimized for single row invocation."]
    #[doc = " \\note"]
    #[doc = " You should pre-allocate memory for ``out_result``:"]
    #[doc = "   - for normal and raw score, its length is equal to ``num_class * num_data``;"]
    #[doc = "   - for leaf index, its length is equal to ``num_class * num_data * num_iteration``;"]
    #[doc = "   - for feature contributions, its length is equal to ``num_class * num_data * (num_feature + 1)``."]
    #[doc = " \\param handle Handle of booster"]
    #[doc = " \\param data Pointer to the data space"]
    #[doc = " \\param data_type Type of ``data`` pointer, can be ``C_API_DTYPE_FLOAT32`` or ``C_API_DTYPE_FLOAT64``"]
    #[doc = " \\param ncol Number columns"]
    #[doc = " \\param is_row_major 1 for row-major, 0 for column-major"]
    #[doc = " \\param predict_type What should be predicted"]
    #[doc = "   - ``C_API_PREDICT_NORMAL``: normal prediction, with transform (if needed);"]
    #[doc = "   - ``C_API_PREDICT_RAW_SCORE``: raw score;"]
    #[doc = "   - ``C_API_PREDICT_LEAF_INDEX``: leaf index;"]
    #[doc = "   - ``C_API_PREDICT_CONTRIB``: feature contributions (SHAP values)"]
    #[doc = " \\param start_iteration Start index of the iteration to predict"]
    #[doc = " \\param num_iteration Number of iteration for prediction, <= 0 means no limit"]
    #[doc = " \\param parameter Other parameters for prediction, e.g. early stopping for prediction"]
    #[doc = " \\param[out] out_len Length of output result"]
    #[doc = " \\param[out] out_result Pointer to array with predictions"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterPredictForMatSingleRow(
        handle: BoosterHandle,
        data: *const ::std::os::raw::c_void,
        data_type: ::std::os::raw::c_int,
        ncol: ::std::os::raw::c_int,
        is_row_major: ::std::os::raw::c_int,
        predict_type: ::std::os::raw::c_int,
        start_iteration: ::std::os::raw::c_int,
        num_iteration: ::std::os::raw::c_int,
        parameter: *const ::std::os::raw::c_char,
        out_len: *mut i64,
        out_result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Initialize and return a ``FastConfigHandle`` for use with ``LGBM_BoosterPredictForMatSingleRowFast``."]
    #[doc = ""]
    #[doc = " Release the ``FastConfig`` by passing its handle to ``LGBM_FastConfigFree`` when no longer needed."]
    #[doc = ""]
    #[doc = " \\param handle Booster handle"]
    #[doc = " \\param predict_type What should be predicted"]
    #[doc = "   - ``C_API_PREDICT_NORMAL``: normal prediction, with transform (if needed);"]
    #[doc = "   - ``C_API_PREDICT_RAW_SCORE``: raw score;"]
    #[doc = "   - ``C_API_PREDICT_LEAF_INDEX``: leaf index;"]
    #[doc = "   - ``C_API_PREDICT_CONTRIB``: feature contributions (SHAP values)"]
    #[doc = " \\param start_iteration Start index of the iteration to predict"]
    #[doc = " \\param num_iteration Number of iterations for prediction, <= 0 means no limit"]
    #[doc = " \\param data_type Type of ``data`` pointer, can be ``C_API_DTYPE_FLOAT32`` or ``C_API_DTYPE_FLOAT64``"]
    #[doc = " \\param ncol Number of columns"]
    #[doc = " \\param parameter Other parameters for prediction, e.g. early stopping for prediction"]
    #[doc = " \\param[out] out_fastConfig FastConfig object with which you can call ``LGBM_BoosterPredictForMatSingleRowFast``"]
    #[doc = " \\return 0 when it succeeds, -1 when failure happens"]
    pub fn LGBM_BoosterPredictForMatSingleRowFastInit(
        handle: BoosterHandle,
        predict_type: ::std::os::raw::c_int,
        start_iteration: ::std::os::raw::c_int,
        num_iteration: ::std::os::raw::c_int,
        data_type: ::std::os::raw::c_int,
        ncol: i32,
        parameter: *const ::std::os::raw::c_char,
        out_fastConfig: *mut FastConfigHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Faster variant of ``LGBM_BoosterPredictForMatSingleRow``."]
    #[doc = ""]
    #[doc = " Score a single row after setup with ``LGBM_BoosterPredictForMatSingleRowFastInit``."]
    #[doc = ""]
    #[doc = " By removing the setup steps from this call extra optimizations can be made like"]
    #[doc = " initializing the config only once, instead of once per call."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = "   Setting up the number of threads is only done once at ``LGBM_BoosterPredictForMatSingleRowFastInit``"]
    #[doc = "   instead of at each prediction."]
    #[doc = "   If you use a different number of threads in other calls, you need to start the setup process over,"]
    #[doc = "   or that number of threads will be used for these calls as well."]
    #[doc = ""]
    #[doc = " \\param fastConfig_handle FastConfig object handle returned by ``LGBM_BoosterPredictForMatSingleRowFastInit``"]
    #[doc = " \\param data Single-row array data (no other way than row-major form)."]
    #[doc = " \\param[out] out_len Length of output result"]
    #[doc = " \\param[out] out_result Pointer to array with predictions"]
    #[doc = " \\return 0 when it succeeds, -1 when failure happens"]
    pub fn LGBM_BoosterPredictForMatSingleRowFast(
        fastConfig_handle: FastConfigHandle,
        data: *const ::std::os::raw::c_void,
        out_len: *mut i64,
        out_result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Make prediction for a new dataset presented in a form of array of pointers to rows."]
    #[doc = " \\note"]
    #[doc = " You should pre-allocate memory for ``out_result``:"]
    #[doc = "   - for normal and raw score, its length is equal to ``num_class * num_data``;"]
    #[doc = "   - for leaf index, its length is equal to ``num_class * num_data * num_iteration``;"]
    #[doc = "   - for feature contributions, its length is equal to ``num_class * num_data * (num_feature + 1)``."]
    #[doc = " \\param handle Handle of booster"]
    #[doc = " \\param data Pointer to the data space"]
    #[doc = " \\param data_type Type of ``data`` pointer, can be ``C_API_DTYPE_FLOAT32`` or ``C_API_DTYPE_FLOAT64``"]
    #[doc = " \\param nrow Number of rows"]
    #[doc = " \\param ncol Number columns"]
    #[doc = " \\param predict_type What should be predicted"]
    #[doc = "   - ``C_API_PREDICT_NORMAL``: normal prediction, with transform (if needed);"]
    #[doc = "   - ``C_API_PREDICT_RAW_SCORE``: raw score;"]
    #[doc = "   - ``C_API_PREDICT_LEAF_INDEX``: leaf index;"]
    #[doc = "   - ``C_API_PREDICT_CONTRIB``: feature contributions (SHAP values)"]
    #[doc = " \\param start_iteration Start index of the iteration to predict"]
    #[doc = " \\param num_iteration Number of iteration for prediction, <= 0 means no limit"]
    #[doc = " \\param parameter Other parameters for prediction, e.g. early stopping for prediction"]
    #[doc = " \\param[out] out_len Length of output result"]
    #[doc = " \\param[out] out_result Pointer to array with predictions"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterPredictForMats(
        handle: BoosterHandle,
        data: *mut *const ::std::os::raw::c_void,
        data_type: ::std::os::raw::c_int,
        nrow: i32,
        ncol: i32,
        predict_type: ::std::os::raw::c_int,
        start_iteration: ::std::os::raw::c_int,
        num_iteration: ::std::os::raw::c_int,
        parameter: *const ::std::os::raw::c_char,
        out_len: *mut i64,
        out_result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Save model into file."]
    #[doc = " \\param handle Handle of booster"]
    #[doc = " \\param start_iteration Start index of the iteration that should be saved"]
    #[doc = " \\param num_iteration Index of the iteration that should be saved, <= 0 means save all"]
    #[doc = " \\param feature_importance_type Type of feature importance, can be ``C_API_FEATURE_IMPORTANCE_SPLIT`` or ``C_API_FEATURE_IMPORTANCE_GAIN``"]
    #[doc = " \\param filename The name of the file"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterSaveModel(
        handle: BoosterHandle,
        start_iteration: ::std::os::raw::c_int,
        num_iteration: ::std::os::raw::c_int,
        feature_importance_type: ::std::os::raw::c_int,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Save model to string."]
    #[doc = " \\param handle Handle of booster"]
    #[doc = " \\param start_iteration Start index of the iteration that should be saved"]
    #[doc = " \\param num_iteration Index of the iteration that should be saved, <= 0 means save all"]
    #[doc = " \\param feature_importance_type Type of feature importance, can be ``C_API_FEATURE_IMPORTANCE_SPLIT`` or ``C_API_FEATURE_IMPORTANCE_GAIN``"]
    #[doc = " \\param buffer_len String buffer length, if ``buffer_len < out_len``, you should re-allocate buffer"]
    #[doc = " \\param[out] out_len Actual output length"]
    #[doc = " \\param[out] out_str String of model, should pre-allocate memory"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterSaveModelToString(
        handle: BoosterHandle,
        start_iteration: ::std::os::raw::c_int,
        num_iteration: ::std::os::raw::c_int,
        feature_importance_type: ::std::os::raw::c_int,
        buffer_len: i64,
        out_len: *mut i64,
        out_str: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Dump model to JSON."]
    #[doc = " \\param handle Handle of booster"]
    #[doc = " \\param start_iteration Start index of the iteration that should be dumped"]
    #[doc = " \\param num_iteration Index of the iteration that should be dumped, <= 0 means dump all"]
    #[doc = " \\param feature_importance_type Type of feature importance, can be ``C_API_FEATURE_IMPORTANCE_SPLIT`` or ``C_API_FEATURE_IMPORTANCE_GAIN``"]
    #[doc = " \\param buffer_len String buffer length, if ``buffer_len < out_len``, you should re-allocate buffer"]
    #[doc = " \\param[out] out_len Actual output length"]
    #[doc = " \\param[out] out_str JSON format string of model, should pre-allocate memory"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterDumpModel(
        handle: BoosterHandle,
        start_iteration: ::std::os::raw::c_int,
        num_iteration: ::std::os::raw::c_int,
        feature_importance_type: ::std::os::raw::c_int,
        buffer_len: i64,
        out_len: *mut i64,
        out_str: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get leaf value."]
    #[doc = " \\param handle Handle of booster"]
    #[doc = " \\param tree_idx Index of tree"]
    #[doc = " \\param leaf_idx Index of leaf"]
    #[doc = " \\param[out] out_val Output result from the specified leaf"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterGetLeafValue(handle: BoosterHandle, tree_idx: ::std::os::raw::c_int, leaf_idx: ::std::os::raw::c_int, out_val: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set leaf value."]
    #[doc = " \\param handle Handle of booster"]
    #[doc = " \\param tree_idx Index of tree"]
    #[doc = " \\param leaf_idx Index of leaf"]
    #[doc = " \\param val Leaf value"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterSetLeafValue(handle: BoosterHandle, tree_idx: ::std::os::raw::c_int, leaf_idx: ::std::os::raw::c_int, val: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get model feature importance."]
    #[doc = " \\param handle Handle of booster"]
    #[doc = " \\param num_iteration Number of iterations for which feature importance is calculated, <= 0 means use all"]
    #[doc = " \\param importance_type Method of importance calculation:"]
    #[doc = "   - ``C_API_FEATURE_IMPORTANCE_SPLIT``: result contains numbers of times the feature is used in a model;"]
    #[doc = "   - ``C_API_FEATURE_IMPORTANCE_GAIN``: result contains total gains of splits which use the feature"]
    #[doc = " \\param[out] out_results Result array with feature importance"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterFeatureImportance(
        handle: BoosterHandle,
        num_iteration: ::std::os::raw::c_int,
        importance_type: ::std::os::raw::c_int,
        out_results: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get model upper bound value."]
    #[doc = " \\param handle Handle of booster"]
    #[doc = " \\param[out] out_results Result pointing to max value"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterGetUpperBoundValue(handle: BoosterHandle, out_results: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get model lower bound value."]
    #[doc = " \\param handle Handle of booster"]
    #[doc = " \\param[out] out_results Result pointing to min value"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_BoosterGetLowerBoundValue(handle: BoosterHandle, out_results: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Initialize the network."]
    #[doc = " \\param machines List of machines in format 'ip1:port1,ip2:port2'"]
    #[doc = " \\param local_listen_port TCP listen port for local machines"]
    #[doc = " \\param listen_time_out Socket time-out in minutes"]
    #[doc = " \\param num_machines Total number of machines"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_NetworkInit(
        machines: *const ::std::os::raw::c_char,
        local_listen_port: ::std::os::raw::c_int,
        listen_time_out: ::std::os::raw::c_int,
        num_machines: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Finalize the network."]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_NetworkFree() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Initialize the network with external collective functions."]
    #[doc = " \\param num_machines Total number of machines"]
    #[doc = " \\param rank Rank of local machine"]
    #[doc = " \\param reduce_scatter_ext_fun The external reduce-scatter function"]
    #[doc = " \\param allgather_ext_fun The external allgather function"]
    #[doc = " \\return 0 when succeed, -1 when failure happens"]
    pub fn LGBM_NetworkInitWithFunctions(
        num_machines: ::std::os::raw::c_int,
        rank: ::std::os::raw::c_int,
        reduce_scatter_ext_fun: *mut ::std::os::raw::c_void,
        allgather_ext_fun: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>(), 24usize, concat!("Size of: ", stringify!(__va_list_tag)));
    assert_eq!(::std::mem::align_of::<__va_list_tag>(), 8usize, concat!("Alignment of ", stringify!(__va_list_tag)));
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(__va_list_tag), "::", stringify!(gp_offset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(__va_list_tag), "::", stringify!(fp_offset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(__va_list_tag), "::", stringify!(overflow_arg_area))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(__va_list_tag), "::", stringify!(reg_save_area))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
